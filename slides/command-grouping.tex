
\begin{frame}
	\frametitle{Подстановка команд}
	
	Синтаксис:

	\begin{itemize}
		\item \`{}command\`{}
		\item \$(command)
	\end{itemize}
	\pause
	\begin{block}{Задание}
		Присвоить переменной LIST результат выполнения команды {\tt ls -1} \\
		Вывести на экран переменную LIST
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Коды возврата}

	Согласно POSIX: 0 -- успех

	Код возврата доступен через переменную \$?

	\pause
	\begin{block}{Пример}
		\begin{lstlisting}
/bin/true; echo $?
/bin/false; echo $?
		\end{lstlisting}
	\end{block}

	Скрипт возвращает код последней команды, поэтому для корректного выхода необходимо использовать {\tt exit}.

\end{frame}


\begin{frame}[fragile]
	\frametitle{exec}

	Заменяет текущий shell переданной командой. 

	Часто используется для переназначения файловых дескрипторов.

    \begin{block}{Пример.Открываем файловый дескриптор}
      \begin{lstlisting}
exec 3<> /tmp/myfile
echo "test" >&3
exec 3>& # Закрытие
      \end{lstlisting}
    \end{block}

\end{frame}

\begin{frame}[fragile]
	\frametitle{Группировка}
	
	\begin{block}{Пример}
		\begin{lstlisting}
( echo 1; echo 2) | tee file
		\end{lstlisting}
	\end{block}

	\pause
	\begin{block}{( cmd1; cmd2)}
	    Запускается новый shell
	\end{block}

	\begin{block}{Пример}
		\begin{lstlisting}
TEST=42; (echo $TEST; TEST=0; echo $TEST ); echo $TEST
		\end{lstlisting}
	\end{block}

\end{frame}


